<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <title>Chattime Capture</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />

  <!-- Fonts giống watermark -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Big+Shoulders+Display:wght@700&family=Roboto:wght@100;300;400;500;700;900&family=Roboto+Condensed:wght@300;400;500;700&display=swap"
    rel="stylesheet" />

  <style>
    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050505;
      color: #f5f5f5;
    }

    body {
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app {
      width: 100%;
      max-width: 480px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      padding: 12px;
      gap: 12px;
    }

    h1 {
      font-size: 18px;
      margin: 0;
      text-align: center;
    }

    .card {
      background: #121212;
      border-radius: 12px;
      padding: 12px 12px 14px;
      box-shadow: 0 0 0 1px #222, 0 10px 30px rgba(0, 0, 0, 0.7);
    }

    .card h2 {
      font-size: 15px;
      margin: 0 0 8px;
    }

    label {
      font-size: 13px;
      display: block;
      margin-bottom: 4px;
    }

    input[type="text"],
    input[type="time"],
    input[type="file"],
    button {
      width: 100%;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #333;
      background: #1c1c1c;
      color: #eee;
      font-size: 14px;
    }

    input[type="file"] {
      padding: 4px 0;
      background: transparent;
      border: none;
    }

    input::placeholder {
      color: #777;
    }

    .row {
      display: flex;
      gap: 8px;
    }

    .row>div {
      flex: 1;
    }

    .hint {
      font-size: 11px;
      color: #999;
      margin-top: 4px;
    }

    button {
      cursor: pointer;
      font-weight: 600;
      background: #0f766e;
      border-color: #0f766e;
    }

    button.secondary {
      background: #2a2a2a;
      border-color: #444;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    #step-camera {
      display: none;
    }

    .frame-wrapper {
      display: flex;
      justify-content: center;
      margin-top: 8px;
    }

    .frame {
      position: relative;
      width: 100%;
      max-width: 360px;
      aspect-ratio: 3/4;
      /* gần 960x1280 */
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 0 0 1px #222;
    }

    #previewCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
    }

    .status {
      font-size: 12px;
      color: #ccc;
      white-space: pre-line;
      margin-top: 4px;
    }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #1e293b;
      font-size: 11px;
      color: #e5e7eb;
      margin-left: 4px;
    }

    .actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .actions button {
      flex: 1;
    }

    #lastShot {
      margin-top: 10px;
      font-size: 11px;
      color: #aaa;
    }

    #lastShot img {
      width: 100%;
      border-radius: 6px;
      margin-top: 4px;
      background: #000;
    }

    #downloadBtn {
      margin-top: 6px;
    }

    video#videoSource {
      display: none;
    }
  </style>
</head>

<body>
  <div class="app">
    <h1>Chattime Capture</h1>

    <!-- STEP 1: cấu hình watermark -->
    <section id="step-config" class="card">
      <h2>Bước 1: Thông tin watermark</h2>

      <div class="row">
        <div>
          <label for="timeInput">Giờ (HH:MM)</label>
          <input id="timeInput" type="time" step="60">
        </div>
        <div>
          <label>Ngày & Thứ (UTC+7)</label>
          <div id="datePreview" class="hint"></div>
        </div>
      </div>

      <div style="margin-top:8px;">
        <label for="nameInput">Họ tên</label>
        <input id="nameInput" type="text" placeholder="Họ tên người dùng">
      </div>

      <div style="margin-top:8px;">
        <label for="addressInput">Địa chỉ</label>
        <input id="addressInput" type="text" placeholder="Địa chỉ chụp">
      </div>

      <div style="margin-top:8px;">
        <label for="layoutFile">Layout JSON (tùy chọn)</label>
        <input id="layoutFile" type="file" accept="application/json">
        <div class="hint">
          Nếu không chọn, sẽ dùng layout mặc định (960×1280).<br>
          Dùng JSON export từ overlay-tool.
        </div>
        <div id="layoutInfo" class="status"></div>
      </div>

      <div style="margin-top:8px;">
        <button id="startCameraBtn">Xác nhận & mở camera</button>
        <div id="configStatus" class="status"></div>
      </div>
    </section>

    <!-- STEP 2: camera + preview canvas -->
    <section id="step-camera" class="card">
      <h2>Bước 2: Camera & watermark <span class="badge">960×1280</span></h2>

      <div class="frame-wrapper">
        <div class="frame">
          <canvas id="previewCanvas" width="960" height="1280"></canvas>
        </div>
      </div>

      <div class="actions">
        <button id="captureBtn">Chụp</button>
        <button id="backBtn" class="secondary">Quay lại</button>
      </div>

      <div id="cameraStatus" class="status"></div>

      <div id="lastShot">
        <!-- ảnh kết quả + nút tải sẽ nằm ở đây -->
      </div>
      <button id="downloadBtn" disabled>Tải ảnh</button>
    </section>

    <!-- video nguồn (ẩn) -->
    <video id="videoSource" autoplay playsinline muted></video>
  </div>

  <script>
    // ===== DOM refs =====
    const stepConfig = document.getElementById("step-config");
    const stepCamera = document.getElementById("step-camera");

    const timeInput = document.getElementById("timeInput");
    const nameInput = document.getElementById("nameInput");
    const addressInput = document.getElementById("addressInput");
    const datePreview = document.getElementById("datePreview");

    const layoutFileInput = document.getElementById("layoutFile");
    const layoutInfo = document.getElementById("layoutInfo");
    const configStatus = document.getElementById("configStatus");

    const startCameraBtn = document.getElementById("startCameraBtn");
    const backBtn = document.getElementById("backBtn");
    const captureBtn = document.getElementById("captureBtn");
    const cameraStatus = document.getElementById("cameraStatus");

    const previewCanvas = document.getElementById("previewCanvas");
    const ctx = previewCanvas.getContext("2d");

    const videoSource = document.getElementById("videoSource");
    const lastShotContainer = document.getElementById("lastShot");
    const downloadBtn = document.getElementById("downloadBtn");

    // ===== state =====
    let currentLayout = null;
    let bindings = null;  // map các item text
    let mediaStream = null;
    let previewLoopId = null;
    let currentUserData = null;
    let lastShotDataUrl = null;

    const CANVAS_W = 960;
    const CANVAS_H = 1280;

    // ===== default layout 960x1280: CHÍNH LÀ JSON BẠN GỬI =====
    const defaultLayout = {
      "imageWidth": 960,
      "imageHeight": 1280,
      "items": [
        {
          "id": "text-1",
          "type": "text",
          "left": 22,
          "top": 970,
          "width": 179,
          "height": 120,
          "leftPercent": 0.0226,
          "topPercent": 0.7575,
          "text": "19:35",
          "fontFamily": "\"Big Shoulders Display\", sans-serif",
          "fontSize": 100,
          "fontWeight": "300",
          "color": "#ffffff",
          "strokeWidth": 1,
          "strokeColor": "#000000",
          "strokeOpacity": 1
        },
        {
          "id": "line-1",
          "type": "line",
          "left": 215,
          "top": 986,
          "width": 4,
          "height": 85,
          "leftPercent": 0.2244,
          "topPercent": 0.7701,
          "lineLength": 85,
          "lineThickness": 4,
          "lineColor": "#e0b642",
          "lineAngle": 90
        },
        {
          "id": "text-2",
          "type": "text",
          "left": 237,
          "top": 982,
          "width": 300,
          "height": 38,
          "leftPercent": 0.2469,
          "topPercent": 0.7672,
          "text": "17 Tháng 11, 2025",
          "fontFamily": "\"Roboto Condensed\", sans-serif",
          "fontSize": 31,
          "fontWeight": "400",
          "color": "#ffffff",
          "strokeWidth": 1,
          "strokeColor": "#424242",
          "strokeOpacity": 0.5
        },
        {
          "id": "text-3",
          "type": "text",
          "left": 23,
          "top": 1091,
          "width": 607,
          "height": 76,
          "leftPercent": 0.024,
          "topPercent": 0.8523,
          "text": "19 Bùi Quốc Khái, P. Long Thạnh Mỹ, TP. Thủ Đức, Thành Phố Hồ Chí Minh",
          "fontFamily": "\"Roboto Condensed\", sans-serif",
          "fontSize": 31,
          "fontWeight": "400",
          "color": "#ffffff",
          "strokeWidth": 1,
          "strokeColor": "#424242",
          "strokeOpacity": 0.5
        },
        {
          "id": "text-4",
          "type": "text",
          "left": 237,
          "top": 1036,
          "width": 150,
          "height": 38,
          "leftPercent": 0.2465,
          "topPercent": 0.8096,
          "text": "Thứ Hai",
          "fontFamily": "\"Roboto Condensed\", sans-serif",
          "fontSize": 31,
          "fontWeight": "400",
          "color": "#ffffff",
          "strokeWidth": 1,
          "strokeColor": "#424242",
          "strokeOpacity": 0.5
        },
        {
          "id": "text-5",
          "type": "text",
          "left": 40,
          "top": 1194,
          "width": 300,
          "height": 38,
          "leftPercent": 0.042,
          "topPercent": 0.933,
          "text": "Họ tên: TRẦN GIA LINH",
          "fontFamily": "\"Roboto Condensed\", sans-serif",
          "fontSize": 31,
          "fontWeight": "400",
          "color": "#ffffff",
          "strokeWidth": 1,
          "strokeColor": "#424242",
          "strokeOpacity": 0.5
        },
        {
          "id": "text-6",
          "type": "text",
          "left": 815,
          "top": 1210,
          "width": 70,
          "height": 34,
          "leftPercent": 0.849,
          "topPercent": 0.9453,
          "text": "Time",
          "fontFamily": "Roboto, sans-serif",
          "fontSize": 28,
          "fontWeight": "700",
          "color": "#f4ba36",
          "strokeWidth": 1,
          "strokeColor": "#454545",
          "strokeOpacity": 0.25
        },
        {
          "id": "text-7",
          "type": "text",
          "left": 819,
          "top": 1243,
          "width": 132,
          "height": 26,
          "leftPercent": 0.8531,
          "topPercent": 0.9711,
          "text": "100% Chân thực",
          "fontFamily": "\"Roboto Condensed\", sans-serif",
          "fontSize": 20,
          "fontWeight": "400",
          "color": "#ffffff",
          "strokeWidth": 1,
          "strokeColor": "#000000",
          "strokeOpacity": 0.15
        },
        {
          "id": "text-8",
          "type": "text",
          "left": 880,
          "top": 1210,
          "width": 70,
          "height": 34,
          "leftPercent": 0.9167,
          "topPercent": 0.9453,
          "text": "mark",
          "fontFamily": "Roboto, sans-serif",
          "fontSize": 28,
          "fontWeight": "700",
          "color": "#ffffff",
          "strokeWidth": 1,
          "strokeColor": "#454545",
          "strokeOpacity": 0.35
        },
        {
          "id": "rect-1",
          "type": "rect",
          "left": 28,
          "top": 1176,
          "width": 300,
          "height": 75,
          "leftPercent": 0.0287,
          "topPercent": 0.9191,
          "rectWidth": 300,
          "rectHeight": 75,
          "rectFillColor": "#ffffff",
          "rectOpacity": 0.3,
          "rectRadius": 5,
          "rectGradient": "fade-ltr",
          "rectFade": true
        }
      ]
    };

    // ===== date/time helpers =====
    function getNowVietnam() {
      const now = new Date();
      const fmtDate = new Intl.DateTimeFormat("vi-VN", {
        timeZone: "Asia/Bangkok",
        day: "2-digit",
        month: "2-digit",
        year: "numeric"
      });
      const fmtWeekday = new Intl.DateTimeFormat("vi-VN", {
        timeZone: "Asia/Bangkok",
        weekday: "long"
      });
      const fmtTime = new Intl.DateTimeFormat("vi-VN", {
        timeZone: "Asia/Bangkok",
        hour: "2-digit",
        minute: "2-digit",
        hour12: false
      });

      const [day, month, year] = fmtDate.format(now).split("/");
      const weekdayRaw = fmtWeekday.format(now);
      const weekday = weekdayRaw.charAt(0).toUpperCase() + weekdayRaw.slice(1);
      const timeStr = fmtTime.format(now);
      const dateStr = `${day} Tháng ${parseInt(month, 10)}, ${year}`;

      return { day, month, year, weekday, timeStr, dateStr };
    }

    function updateDatePreview() {
      const { dateStr, weekday, timeStr } = getNowVietnam();
      if (!timeInput.value) {
        timeInput.value = timeStr;
      }
      datePreview.textContent = `${dateStr}\n${weekday}`;
    }

    // ===== color helper =====
    function hexToRgba(input, alpha) {
      if (!input) return input;
      let color = input.trim();
      const rgbaMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/i);
      if (rgbaMatch) {
        const r = parseInt(rgbaMatch[1], 10);
        const g = parseInt(rgbaMatch[2], 10);
        const b = parseInt(rgbaMatch[3], 10);
        const a = (typeof alpha === "number")
          ? alpha
          : (rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1);
        return `rgba(${r}, ${g}, ${b}, ${a})`;
      }
      if (color[0] === "#") color = color.slice(1);
      if (color.length === 3) {
        color = color.split("").map(c => c + c).join("");
      }
      if (color.length === 6) {
        const r = parseInt(color.slice(0, 2), 16);
        const g = parseInt(color.slice(2, 4), 16);
        const b = parseInt(color.slice(4, 6), 16);
        const a = (typeof alpha === "number") ? alpha : 1;
        return `rgba(${r}, ${g}, ${b}, ${a})`;
      }
      return input;
    }

    // ===== layout helpers =====
    // ƯU TIÊN PX -> giống overlay-tool (dom toạ độ px)
    function computeCoord(px, percent, total, scale) {
      if (typeof px === "number") return px * scale;
      if (typeof percent === "number") return percent * total;
      return 0;
    }

    function scaleValue(v, scale) {
      if (typeof v !== "number") return v;
      return v * scale;
    }

    function analyzeBindings(layout) {
      const items = layout.items || [];
      let timeItem = null;
      let dateItem = null;
      let weekdayItem = null;
      let addressItem = null;
      let nameItem = null;

      for (const it of items) {
        if (it.type !== "text") continue;
        const id = it.id || "";
        if (!timeItem && (id === "time" || id === "text-1")) timeItem = it;
        if (!dateItem && (id === "date" || id === "text-2")) dateItem = it;
        if (!addressItem && (id === "address" || id === "text-3")) addressItem = it;
        if (!weekdayItem && (id === "weekday" || id === "text-4")) weekdayItem = it;
        if (!nameItem && (id === "name" || id === "text-5")) nameItem = it;
      }

      for (const it of items) {
        if (it.type !== "text") continue;
        const txt = (it.text || "").trim();
        if (!timeItem && /^\d{1,2}:\d{2}$/.test(txt)) timeItem = it;
        if (!dateItem && /Tháng\s+\d+,\s+\d{4}/.test(txt)) dateItem = it;
        if (!weekdayItem && /Thứ|Chủ Nhật|Chủ nhật/.test(txt)) weekdayItem = it;
        if (!nameItem && /^Họ tên/i.test(txt)) nameItem = it;
      }

      if (!addressItem) {
        let longest = null;
        for (const it of items) {
          if (it.type !== "text") continue;
          if (it === timeItem || it === dateItem || it === weekdayItem || it === nameItem) continue;
          if (!longest || (it.text || "").length > (longest.text || "").length) {
            longest = it;
          }
        }
        addressItem = longest;
      }

      return { timeItem, dateItem, weekdayItem, addressItem, nameItem };
    }

    // ===== TEXT DRAWING: dùng baseline "top" như DIV =====
    function drawWrappedTextWithBaseline(ctx, text, x, topY, maxWidth, lineHeight, _ascent, doStroke) {
      const words = text.split(/\s+/);
      let line = "";
      let lineIndex = 0;

      for (let i = 0; i < words.length; i++) {
        const testLine = line ? (line + " " + words[i]) : words[i];
        const w = ctx.measureText(testLine).width;
        if (w > maxWidth && line) {
          const y = topY + lineIndex * lineHeight;
          if (doStroke) ctx.strokeText(line, x, y);
          ctx.fillText(line, x, y);
          line = words[i];
          lineIndex++;
        } else {
          line = testLine;
        }
      }

      if (line) {
        const y = topY + lineIndex * lineHeight;
        if (doStroke) ctx.strokeText(line, x, y);
        ctx.fillText(line, x, y);
      }
    }

    function drawTextItem(ctx, item, canvasW, canvasH, scaleX, scaleY, overrideText) {
      const x = computeCoord(item.left, item.leftPercent, canvasW, scaleX);
      const topY = computeCoord(item.top, item.topPercent, canvasH, scaleY);

      const fontSize = scaleValue(item.fontSize || 20, scaleY);
      const fontWeight = item.fontWeight || "400";
      const fontFamily = item.fontFamily || "sans-serif";

      ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
      ctx.textBaseline = "top"; // QUAN TRỌNG: top giống overlay-tool

      // ✅ Thêm 2 dòng này để chữ lấy đúng màu từ JSON
      const fillColor = item.color || "#ffffff";
      ctx.fillStyle = fillColor;

      const text = (overrideText != null ? overrideText : (item.text || "")).toString();

      const metrics = ctx.measureText(text || "A");
      const ascent = metrics.actualBoundingBoxAscent || fontSize * 0.8;
      const descent = metrics.actualBoundingBoxDescent || fontSize * 0.2;
      const lineHeight = (ascent + descent) * 1.1;

      const maxWidth = (typeof item.width === "number" && item.width > 0)
        ? scaleValue(item.width, scaleX)
        : null;

      const sw = item.strokeWidth || 0;
      const sc = item.strokeColor || "#000000";
      const so = (item.strokeOpacity === undefined ? 0 : item.strokeOpacity);
      const doStroke = sw > 0 && so > 0;
      if (doStroke) {
        ctx.strokeStyle = hexToRgba(sc, so);
        ctx.lineWidth = sw * scaleY * 2;
      } else {
        ctx.lineWidth = 0;
      }

      if (maxWidth) {
        drawWrappedTextWithBaseline(ctx, text, x, topY, maxWidth, lineHeight, ascent, doStroke);
      } else {
        const y = topY;
        if (doStroke) ctx.strokeText(text, x, y);
        ctx.fillText(text, x, y);
      }
    }

    // ===== LINE =====
    function drawLineItem(ctx, item, canvasW, canvasH, scaleX, scaleY) {
      const rectX = computeCoord(item.left, item.leftPercent, canvasW, scaleX);
      const rectY = computeCoord(item.top, item.topPercent, canvasH, scaleY);
      const rectW = scaleValue(item.width || item.lineLength || 200, scaleX);
      const rectH = scaleValue(item.height || item.lineThickness || 4, scaleY);

      const baseLength = (typeof item.lineLength === "number" ? item.lineLength :
        (typeof item.width === "number" ? item.width : 200));
      const baseThickness = (typeof item.lineThickness === "number" ? item.lineThickness :
        (typeof item.height === "number" ? item.height : 4));

      const length = scaleValue(baseLength, scaleX);
      const thickness = scaleValue(baseThickness, scaleY);
      const color = item.lineColor || "#e0b642";
      const angleDeg = item.lineAngle || 0;
      const angleRad = angleDeg * Math.PI / 180;

      const cx = rectX + rectW / 2;
      const cy = rectY + rectH / 2;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angleRad);
      ctx.fillStyle = color;
      ctx.fillRect(-length / 2, -thickness / 2, length, thickness);
      ctx.restore();
    }

    function drawRectItem(ctx, item, canvasW, canvasH, scaleX, scaleY) {
      const baseW = (typeof item.rectWidth === "number" ? item.rectWidth :
        (typeof item.width === "number" ? item.width : 200));
      const baseH = (typeof item.rectHeight === "number" ? item.rectHeight :
        (typeof item.height === "number" ? item.height : 80));

      const w = scaleValue(baseW, scaleX);
      const h = scaleValue(baseH, scaleY);

      const x = computeCoord(item.left, item.leftPercent, canvasW, scaleX);
      const y = computeCoord(item.top, item.topPercent, canvasH, scaleY);

      const color = item.rectFillColor || "rgba(0,0,0,0.3)";
      const opacity = (item.rectOpacity === undefined ? 0.3 : item.rectOpacity);
      const radius = scaleValue(item.rectRadius || 0, (scaleX + scaleY) / 2);

      const fade =
        item.rectGradient === "fade-ltr" ||
        item.rectFade === true ||
        item.rectFade === "true";

      ctx.save();
      ctx.beginPath();
      if (ctx.roundRect) {
        ctx.roundRect(x, y, w, h, radius);
      } else {
        ctx.rect(x, y, w, h);
      }

      if (fade) {
        const grad = ctx.createLinearGradient(x, y, x + w, y);
        grad.addColorStop(0, hexToRgba(color, opacity));
        grad.addColorStop(1, hexToRgba(color, 0));
        ctx.fillStyle = grad;
      } else {
        ctx.fillStyle = hexToRgba(color, opacity);
      }

      ctx.fill();
      ctx.restore();
    }

    function drawWatermark(ctx, canvasW, canvasH, userData) {
      const layout = currentLayout || defaultLayout;
      const baseW = layout.imageWidth || canvasW;
      const baseH = layout.imageHeight || canvasH;
      const scaleX = canvasW / baseW;
      const scaleY = canvasH / baseH;

      const { timeItem, dateItem, weekdayItem, addressItem, nameItem } = bindings || {};

      (layout.items || []).forEach(item => {
        const type = item.type || "text";
        if (type === "text") {
          let override = null;
          if (item === timeItem && userData.timeText) override = userData.timeText;
          if (item === dateItem && userData.dateText) override = userData.dateText;
          if (item === weekdayItem && userData.weekdayText) override = userData.weekdayText;
          if (item === addressItem && userData.addressText) override = userData.addressText;
          if (item === nameItem && userData.nameText) override = userData.nameText;
          drawTextItem(ctx, item, canvasW, canvasH, scaleX, scaleY, override);
        } else if (type === "line") {
          drawLineItem(ctx, item, canvasW, canvasH, scaleX, scaleY);
        } else if (type === "rect") {
          drawRectItem(ctx, item, canvasW, canvasH, scaleX, scaleY);
        }
      });
    }

    // ===== camera =====
    async function waitFontsReady() {
      if (document.fonts && document.fonts.ready) {
        try {
          await document.fonts.ready;
        } catch (e) {
          console.log("fonts.ready error", e);
        }
      }
    }

    async function startCamera() {
      try {
        cameraStatus.textContent = "Đang mở camera...";
        const constraints = {
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1920 },
            height: { ideal: 2560 },
            aspectRatio: { ideal: 3 / 4 }
          },
          audio: false
        };
        mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        videoSource.srcObject = mediaStream;
        await videoSource.play().catch(() => { });
        cameraStatus.textContent = "Camera đã sẵn sàng. Đang chờ font...";
        await waitFontsReady();
        cameraStatus.textContent = "Camera + font sẵn sàng. Giữ máy dọc để chụp.";
        startPreviewLoop();
      } catch (err) {
        console.error(err);
        cameraStatus.textContent = "Không mở được camera. Cần https + quyền camera.";
        alert("Không mở được camera. Trên mobile cần https và cấp quyền camera.");
      }
    }

    function stopCamera() {
      if (previewLoopId != null) {
        cancelAnimationFrame(previewLoopId);
        previewLoopId = null;
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
      }
      videoSource.srcObject = null;
    }

    function startPreviewLoop() {
      if (previewLoopId != null) return;
      const draw = () => {
        previewLoopId = requestAnimationFrame(draw);
        const cw = CANVAS_W;
        const ch = CANVAS_H;

        ctx.clearRect(0, 0, cw, ch);

        const vw = videoSource.videoWidth || 0;
        const vh = videoSource.videoHeight || 0;

        if (vw > 0 && vh > 0) {
          const scale = Math.max(cw / vw, ch / vh);
          const drawW = vw * scale;
          const drawH = vh * scale;
          const dx = (cw - drawW) / 2;
          const dy = (ch - drawH) / 2;
          ctx.drawImage(videoSource, dx, dy, drawW, drawH);
        } else {
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, cw, ch);
        }

        if (currentUserData) {
          drawWatermark(ctx, cw, ch, currentUserData);
        }
      };
      draw();
    }

    // ===== flow =====
    function goStepConfig() {
      stepConfig.style.display = "block";
      stepCamera.style.display = "none";
    }

    function goStepCamera() {
      stepConfig.style.display = "none";
      stepCamera.style.display = "block";
    }

    // ===== events =====
    updateDatePreview();
    setInterval(updateDatePreview, 60_000);

    layoutFileInput.addEventListener("change", (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const json = JSON.parse(reader.result);
          if (!Array.isArray(json.items)) throw new Error("No items");
          currentLayout = json;
          bindings = analyzeBindings(currentLayout);
          layoutInfo.textContent =
            `JSON: OK\nimageWidth=${json.imageWidth}, imageHeight=${json.imageHeight}\nitems=${json.items.length}`;
        } catch (err) {
          console.error(err);
          currentLayout = null;
          bindings = analyzeBindings(defaultLayout);
          layoutInfo.textContent = "JSON không hợp lệ, dùng layout mặc định.";
          alert("File JSON không hợp lệ. Sẽ dùng layout mặc định.");
        }
      };
      reader.readAsText(file, "utf-8");
    });

    startCameraBtn.addEventListener("click", async () => {
      const timeVal = timeInput.value.trim();
      const nameVal = nameInput.value.trim();
      const addrVal = addressInput.value.trim();

      if (!timeVal) {
        alert("Nhập giờ (HH:MM) trước khi chụp.");
        return;
      }
      if (!nameVal) {
        alert("Nhập họ tên.");
        return;
      }
      if (!addrVal) {
        alert("Nhập địa chỉ.");
        return;
      }

      if (!currentLayout) currentLayout = defaultLayout;
      if (!bindings) bindings = analyzeBindings(currentLayout);

      const { dateStr, weekday } = getNowVietnam();
      configStatus.textContent =
        `Sẽ dùng:\nGiờ: ${timeVal}\nNgày: ${dateStr}\nThứ: ${weekday}`;

      currentUserData = {
        timeText: timeVal,
        dateText: dateStr,
        weekdayText: weekday,
        nameText: `Họ tên: ${nameVal}`,
        addressText: addrVal
      };

      goStepCamera();
      await startCamera();
    });

    backBtn.addEventListener("click", () => {
      stopCamera();
      goStepConfig();
    });

    // CHỤP – chỉ lưu lại dataURL & show preview bên dưới
    captureBtn.addEventListener("click", () => {
      if (!currentUserData) {
        alert("Chưa có dữ liệu watermark.");
        return;
      }
      const dataUrl = previewCanvas.toDataURL("image/jpeg", 0.95);
      lastShotDataUrl = dataUrl;

      lastShotContainer.innerHTML =
        `<div>Ảnh đã chụp:</div>
         <img src="${dataUrl}" alt="Last shot" />`;

      downloadBtn.disabled = false;
      cameraStatus.textContent = "Đã chụp xong. Bạn có thể bấm 'Tải ảnh'.";
    });

    // NÚT TẢI ẢNH – tải file JPG, không mở tab mới
    downloadBtn.addEventListener("click", () => {
      if (!lastShotDataUrl) {
        alert("Chưa có ảnh nào để tải. Hãy chụp trước.");
        return;
      }
      const a = document.createElement("a");
      a.href = lastShotDataUrl;
      a.download = `chattime_${Date.now()}.jpg`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });

    // init binding default
    bindings = analyzeBindings(defaultLayout);
  </script>
</body>

</html>